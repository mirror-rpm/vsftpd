diff -up vsftpd-2.1.1/standalone.c.daemonize_plus vsftpd-2.1.1/standalone.c
--- vsftpd-2.1.1/standalone.c.daemonize_plus	2009-04-29 17:46:52.000000000 +0200
+++ vsftpd-2.1.1/standalone.c	2009-04-29 17:46:52.000000000 +0200
@@ -26,6 +26,8 @@ static unsigned int s_ipaddr_size;
 
 static void handle_sigchld(void*  duff);
 static void handle_sighup(void*  duff);
+static void handle_sigusr1(int sig);
+static void handle_sigalrm(int sig);
 static void prepare_child(int sockfd);
 static unsigned int handle_ip_count(void* p_raw_addr);
 static void drop_ip_count(void* p_raw_addr);
@@ -50,7 +52,13 @@ vsf_standalone_main(void)
     if (forkret > 0)
     {
       /* Parent, just exit */
-      vsf_sysutil_exit(0);
+      vsf_sysutil_sigaction(kVSFSysUtilSigALRM, handle_sigalrm);
+      vsf_sysutil_sigaction(kVSFSysUtilSigUSR1, handle_sigusr1);
+
+      vsf_sysutil_set_alarm(3);
+      vsf_sysutil_pause();
+
+      vsf_sysutil_exit(1);
     }
     /* Son, close standard FDs to avoid SSH hang-on-exit */
     vsf_sysutil_reopen_standard_fds();
@@ -98,6 +106,10 @@ vsf_standalone_main(void)
     {
       die("could not bind listening IPv4 socket");
     }
+    else
+    {
+      vsf_sysutil_kill(vsf_sysutil_getppid(), kVSFSysUtilSigUSR1);
+    }
   }
   else
   {
@@ -127,6 +139,10 @@ vsf_standalone_main(void)
     {
       die("could not bind listening IPv6 socket");
     }
+    else
+    {
+      vsf_sysutil_kill(vsf_sysutil_getppid(), kVSFSysUtilSigUSR1);
+    }
   }
   vsf_sysutil_close(0);
   vsf_sysutil_close(1);
@@ -252,6 +268,20 @@ handle_sighup(void* duff)
   vsf_parseconf_load_file(0, 0);
 }
 
+static void
+handle_sigalrm(int sig)
+{
+  (void)sig; // avoid unused parameter error
+  vsf_sysutil_exit(1);
+}
+
+static void
+handle_sigusr1(int sig)
+{
+  (void)sig; // avoid unused parameter error
+  vsf_sysutil_exit(0);
+}
+
 static unsigned int
 hash_ip(unsigned int buckets, void* p_key)
 {
diff -up vsftpd-2.1.1/sysutil.c.daemonize_plus vsftpd-2.1.1/sysutil.c
--- vsftpd-2.1.1/sysutil.c.daemonize_plus	2009-02-26 02:44:29.000000000 +0100
+++ vsftpd-2.1.1/sysutil.c	2009-04-29 17:46:52.000000000 +0200
@@ -201,6 +201,9 @@ vsf_sysutil_translate_sig(const enum EVS
     case kVSFSysUtilSigHUP:
       realsig = SIGHUP;
       break;
+    case kVSFSysUtilSigUSR1:
+      realsig = SIGUSR1;
+      break;
     default:
       bug("unknown signal in vsf_sysutil_translate_sig");
       break;
@@ -538,6 +541,12 @@ vsf_sysutil_getpid(void)
   return (unsigned int) s_current_pid;
 }
 
+unsigned int
+vsf_sysutil_getppid(void)
+{
+  return (unsigned int)getppid();
+}
+
 int
 vsf_sysutil_fork(void)
 {
@@ -1031,6 +1040,18 @@ vsf_sysutil_strdup(const char* p_str)
   return strdup(p_str);
 }
 
+char*
+vsf_sysutil_strndup(const char* p_str, unsigned int p_len)
+{
+  char *new = (char *)malloc(p_len+1);
+
+  if (new == NULL)
+    return NULL;
+
+  new[p_len]='\0';
+  return (char *)memcpy(new, p_str, p_len);
+}
+
 void
 vsf_sysutil_memclr(void* p_dest, unsigned int size)
 {
@@ -2774,3 +2795,23 @@ vsf_sysutil_set_no_fds()
     die("setrlimit NOFILE");
   }
 }
+
+void
+vsf_sysutil_sigaction(const enum EVSFSysUtilSignal sig, void (*p_handlefunc)(int))
+{
+  int realsig = vsf_sysutil_translate_sig(sig);
+  vsf_sysutil_set_sighandler(realsig, p_handlefunc);
+}
+
+int
+vsf_sysutil_kill(int pid, int sig)
+{
+  int realsig = vsf_sysutil_translate_sig(sig);
+  return kill(pid, realsig);
+}
+
+int
+vsf_sysutil_pause()
+{
+  return pause();
+}
diff -up vsftpd-2.1.1/sysutil.h.daemonize_plus vsftpd-2.1.1/sysutil.h
--- vsftpd-2.1.1/sysutil.h.daemonize_plus	2009-02-26 02:47:41.000000000 +0100
+++ vsftpd-2.1.1/sysutil.h	2009-04-29 17:46:52.000000000 +0200
@@ -29,7 +29,8 @@ enum EVSFSysUtilSignal
   kVSFSysUtilSigCHLD,
   kVSFSysUtilSigPIPE,
   kVSFSysUtilSigURG,
-  kVSFSysUtilSigHUP
+  kVSFSysUtilSigHUP,
+  kVSFSysUtilSigUSR1
 };
 enum EVSFSysUtilInterruptContext
 {
@@ -164,6 +165,7 @@ void vsf_sysutil_free(void* p_ptr);
 
 /* Process creation/exit/process handling */
 unsigned int vsf_sysutil_getpid(void);
+unsigned int vsf_sysutil_getppid(void);
 int vsf_sysutil_fork(void);
 int vsf_sysutil_fork_failok(void);
 void vsf_sysutil_exit(int exit_code);
@@ -180,10 +182,14 @@ int vsf_sysutil_wait_exited_normally(
   const struct vsf_sysutil_wait_retval* p_waitret);
 int vsf_sysutil_wait_get_exitcode(
   const struct vsf_sysutil_wait_retval* p_waitret);
+void vsf_sysutil_sigaction(const enum EVSFSysUtilSignal sig, void (*p_handlefunc)(int));
+int vsf_sysutil_kill(int pid, int sig);
+int vsf_sysutil_pause();
 
 /* Various string functions */
 unsigned int vsf_sysutil_strlen(const char* p_text);
 char* vsf_sysutil_strdup(const char* p_str);
+char* vsf_sysutil_strndup(const char* p_str, unsigned int p_len);
 void vsf_sysutil_memclr(void* p_dest, unsigned int size);
 void vsf_sysutil_memcpy(void* p_dest, const void* p_src,
                         const unsigned int size);
